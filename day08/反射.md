Java反射机制
* 定义:
  Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
  
  用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。

* 反射机制的优点与缺点
 为什么要用反射机制？直接创建对象不就可以了吗，这就涉及到了动态与静态的概念
 
 * 静态编译：在编译时确定类型，绑定对象,即通过。
 * 动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。
 
 * 优点:
   可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。
 * 缺点:
   对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。
   
* 理解Class类和类类型
  
  想要了解反射首先理解一下Class类，它是反射实现的基础。
  
  类是java.lang.Class类的实例对象，而Class是所有类的类（There is a class named Class）
  
  对于普通的对象，我们一般都会这样创建和表示：
  > Code code1 = new Code();
  
  上面说了，所有的类都是Class的对象，那么如何表示呢，可不可以通过如下方式呢:
  > Class c = new Class();
  
  但是我们查看Class的源码时，是这样写的：
  ```
     private  Class(ClassLoader loader) { 
         classLoader = loader; 
     }
  ```
  可以看到构造器是私有的，只有JVM可以创建Class的对象，因此不可以像普通类一样new一个Class对象，虽然我们不能new一个Class对象，但是却可以通过已有的类得到一个Class对象，共有三种方式，如下：
  ```
  Class c1 = Code.class;
  这说明任何一个类都有一个隐含的静态成员变量class，这种方式是通过获取类的静态成员变量class得到的
  Class c2 = code1.getClass();
  code1是Code的一个对象，这种方式是通过一个类的对象的getClass()方法获得的
  Class c3 = Class.forName("com.trigl.reflect.Code");
  这种方法是Class类调用forName方法，通过一个类的全量限定名获得
  ```
  这里，c1、c2、c3都是Class的对象，他们是完全一样的，而且有个学名，叫做Code的类类型（class type）。
  这里就让人奇怪了，前面不是说Code是Class的对象吗，而c1、c2、c3也是Class的对象，那么Code和c1、c2、c3不就一样了吗？为什么还叫Code什么类类型？这里不要纠结于它们是否相同，只要理解类类型是干什么的就好了，顾名思义，类类型就是类的类型，也就是描述一个类是什么，都有哪些东西，所以我们可以通过类类型知道一个类的属性和方法，并且可以调用一个类的属性和方法，这就是反射的基础。
  举个简单例子代码：
  ```
  package com.taroballs.mine;
  
  /**
   * Created by taroballs on 17-9-26.
   */
  public class RefelectDemo {
      public static void main(String[] args) throws ClassNotFoundException {
          //第一种：Class c1 = Code.class;
          Class class1 = RefelectDemo.class;//静态变量
          System.out.println(class1.getName());
  
          //第二种：Class c2 = code1.getClass();
          RefelectDemo demo2 = new RefelectDemo();
          Class class2 = demo2.getClass();//类对象的getClass方法
          System.out.println(class2.getName());
  
          //第三种：Class c3 = Class.forName();
          Class class3 = Class.forName("com.taroballs.mine.RefelectDemo");//这里为了避免类为找到，ide强制设置抛出异常
          System.out.println(class3.getName());
          
          /*
          com.taroballs.mine.RefelectDemo
          com.taroballs.mine.RefelectDemo
          com.taroballs.mine.RefelectDemo
           */
      }
  }

  ```
  
* Java反射相关操作
  * 获取成员方法Method
  * 获取成员变量Field
  * 获取构造函数Constructor
  
  ____
  
  * ####获取成员方法信息
    
    单独获取某一个方法是通过Class类的以下方法获得的：
    
    ```
    public Method getDeclaredMethod(String name, Class<?>... parameterTypes) // 得到该类所有的方法，不包括父类的
    public Method getMethod(String name, Class<?>... parameterTypes) // 得到该类所有的public方法，包括父类的
    ```
    两个参数分别是方法名和方法参数类的类类型列表。
    
    例如类A有如下一个方法：
    ```
    public void fun(String name,int age) {
            System.out.println("我叫"+name+",今年"+age+"岁");
        }
    ```
    现在知道A有一个对象a，那么就可以通过：
    ```
    Class c = Class.forName("com.taroballs.mine.RefelectDemo");  //先生成class
    Object o = c.newInstance();                           //newInstance可以初始化一个实例
    Method method = c.getMethod("fun", String.class, int.class);//获取方法
    method.invoke(o, "tengj", 10);       
    ```
    完整代码如下：
    ```
    package com.taroballs.mine;
    
    import java.lang.reflect.Method;
    
    /**
     * Created by taroballs on 17-9-26.
     */
    public class Refelection获取成员方法 {
        public static void main(String[] args) {
            try{
                Class c = Class.forName("com.taroballs.mine.Person");
                Object o = c.newInstance();//调用无参构造方法
                Method method = c.getMethod("fun", String.class , int.class);//获取fun(String,int)方法
                method.invoke(o,"taroballs",24);//注册并调用fun方法
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        /*Result:
        带参数fun方法，我叫taroballs,今年24岁
         */
    }
    ```
    
    有时候我们想获取类中所有成员方法的信息，要怎么办。可以通过以下几步来实现：
    1.获取所有方法的数组：
    ```
    Class c = Class.forName("com.taroballs.mine.Person");
    Method[] methods = c.getDeclaredMethods(); // 得到该类所有的方法，不包括父类的
    或者：
    Method[] methods = c.getMethods();// 得到该类所有的public方法，包括父类的
    ```
    2.然后循环这个数组就得到每个方法了：
    > for (Method method : methods)
    
    完整代码如下：
    
    person类跟上面一样，这里只贴关键代码
    ```
    package com.taroballs.mine;
    
    import java.lang.reflect.Method;
    public class Refelection获取成员每个方法 {
        public static void main(String[] args) {
            try{
                Class c = Class.forName("com.taroballs.mine.Person");
                Method method[] = c.getDeclaredMethods();//得到该类所有的方法，不包括父类的
                for(Method m:method){
                    System.out.println(m.getName());
                }
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        
        /*Result:
        getAge
        setAge
        fun 
        fun
        getName
        setName
         */
    }
    ```
    这里如果把c.getDeclaredMethods();改成c.getMethods();执行结果如下，多了很多方法，以为把Object里面的方法也打印出来了，因为Object是所有类的父类：
    ```
    /*
                Method method[] = c.getMethods();//得到该类包括父类的所有的方法
                Result:
                getAge
                setAge
                fun
                fun
                getName
                setName
                wait
                wait
                wait
                equals
                toString
                hashCode
                getClass
                notify
                notifyAll
                */
    ```
  * ####获取成员变量信息
   想一想成员变量中都包括什么：成员变量类型+成员变量名
   类的成员变量也是一个对象，它是java.lang.reflect.Field的一个对象，所以我们通过java.lang.reflect.Field里面封装的方法来获取这些信息。
   
   单独获取某个成员变量，通过Class类的以下方法实现：
   ```
   public Field getDeclaredField(String name) // 获得该类自身声明的所有变量，不包括其父类的变量
   public Field getField(String name) // 获得该类自所有的public成员变量，包括其父类变量
   ```
   参数是成员变量的名字。
   
   例如一个类A有如下成员变量：
   > private int n;
   
   如果A有一个对象a，当属性不为private时那么就可以这样得到其成员变量：
   ```
   Class c = a.getClass();
   Field field = c.getDeclaredField("n");
   ```
   完整代码如下：
   ```
   package com.taroballs.mine;
   
   import java.lang.reflect.Field;
   
   public class Refelection获取成员变量 {
       public static void main(String[] args) {
           try{
               Class c = Class.forName("com.taroballs.mine.Person");
               //获取成员变量
               Field field = c.getDeclaredField("msg");// //因为msg变量是private的，所以不能用getField方法
               Object o = c.newInstance();//调用无参构造
               field.setAccessible(true);//设置是否允许访问，因为该变量是private的，所以要手动设置允许访问
               Object msg = field.get(o);
               System.out.println(msg);
           }catch (Exception e){
               e.printStackTrace();
           }
       }
       /*Result:
       Hello Taroballs~!
        */
   }
   ```
   同样，如果想要获取所有成员变量的信息，可以通过以下几步
   1.获取所有成员变量的数组：
   ```
   Field[] fields = c.getDeclaredFields();
   for (Field field : fields)
   ```
   完整代码如下：
   ```
   package com.taroballs.mine;
   
   import java.lang.reflect.Field;
   
   public class Refelection获取每个成员变量 {
       public static void main(String[] args) {
           try{
               Class c = Class.forName("com.taroballs.mine.Person");
               Field[] fields = c.getDeclaredFields();
               for (Field f:fields){
                   System.out.println(f.getName());
               }
           }catch (Exception e){
               e.printStackTrace();
           }
       }
       /*Result:
       name
       age
       msg
        */
   }
   ```
   ___
   * ####获取构造函数
   最后再想一想构造函数中都包括什么：构造函数参数
   同上，类的成构造函数也是一个对象，它是java.lang.reflect.Constructor的一个对象，所以我们通过java.lang.reflect.Constructor里面封装的方法来获取这些信息。
   
   单独获取某个构造函数,通过Class类的以下方法实现：
   ```
   public Constructor<T> getDeclaredConstructor(Class<?>... parameterTypes) //  获得该类所有的构造器，不包括其父类的构造器
   public Constructor<T> getConstructor(Class<?>... parameterTypes) // 获得该类所以public构造器，包括父类
   ```
   这个参数为构造函数参数类的类类型列表。
   
   例如类A有如下一个构造函数：
   ```
   public A(String a, int b) {
       // code body
   }
   那么就可以通过：
   Constructor constructor = a.getDeclaredConstructor(String.class, int.class);
   来获取这个构造函数。
   ```
   完整代码如下：
   ```
   import java.lang.reflect.Constructor;
   public class Refelection获取构造函数 {
   public static void main(String[] args) {
        try{
            Class c = Class.forName("com.taroballs.mine.Person");
            Constructor constructor = c.getDeclaredConstructor(String.class,int.class);
            constructor.setAccessible(true);//设置是否允许访问，因为该构造器是private的，所以要手动设置允许访问
            //constructor.newInstance("taroballs",24);
            System.out.println(constructor.newInstance("taroballs",24).toString());
            //成功调用构造函数，并返回类的变量名：com.taroballs.mine.Person@5e2de80c

        }catch (Exception e){
            e.printStackTrace();
        }
     }
   }
   ```
   注意：Class的newInstance方法，只能创建只包含无参数的构造函数的类，
   
   如果某类只有带参数的构造函数，那么就要使用另外一种方式：fromClass.getDeclaredConstructor(String.class,int.class).newInstance("taroballs",24);
   
   ___
   同理，获取所有的构造函数，可以通过以下步骤实现：
   ```
   1.获取该类的所有构造函数，放在一个数组中：
   Constructor[] constructors = c.getDeclaredConstructors();
   2.遍历构造函数数组，获得某个构造函数constructor:
   for (Constructor constructor : constructors)
   ```      
   完整代码如下：
   ```
   package com.taroballs.mine;
   
   import java.lang.reflect.Constructor;
   
   public class Refelection获取每个构造函数 {
       public static void main(String[] args) {
           try{
               Class c = Class.forName("com.taroballs.mine.Person");
               Constructor[] constructors = c.getDeclaredConstructors();
               for(Constructor constructor:constructors){
                   System.out.println(constructor);
               }
           }catch (Exception e){
               e.printStackTrace();
           }
       }
       /*Result:
       public com.taroballs.mine.Person()
       public com.taroballs.mine.Person(java.lang.String,int)
        */
   }

   ```
   ____
   
   * ####通过反射了解集合泛型的本质
   > Java中集合的泛型，是防止错误输入的，只在编译阶段有效，绕过编译到了运行期就无效了。
   
   ![](http://upload-images.jianshu.io/upload_images/1637925-9ce9f69f8b7c26e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
